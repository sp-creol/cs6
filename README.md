# cs6
Problem Set for MIT Opencourse cs 6.0001
[Course webpage](https://ocw.mit.edu/courses/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/pages/lecture-slides-code/)
## course directory
- */ps0*: Problem Set 0: *pkgtest.py*,...
- */ps1*: Problem Set 1: *ps1a.py*, *ps1b.py*, *ps1c.py*
- */ps2*: Problem Set 2: *hangman.py*

## Problem Set 0
Variables x and y receive input from the user with input(). To make the input into ints that can be used for mathematical operations, input() is surrounded by int() to cast the input to ints. Then, the results of x^y and log base 2 of x are printed out, with the latter using numpy's log2() function.

## Problem Set 1
A) The variables portion_down_payment, current_savings, and r are given set values as floats. The variables annual_salary, portion_saved, and total_cost ask for user input and convert the inputs to floats. The months variable is set to 0, and it counts how many times the loop runs. The loop is a while loop that goes until the savings have reached or surpassed the cost of the down payment, or portion_down_payment * total_cost. Every iteration, the current savings first multiplies by 1 plus a twelfth of the annual rate (for the monthly rate), and then it adds the portion of the monthly salary that is saved, given by portion_saved * (annual_salary/12). After the loop completes, the number of months is printed out.
![ps1a](https://user-images.githubusercontent.com/107879635/175646674-446478a6-4e25-4ca2-b2c3-5f0a59cc905b.png)

B) The code now considers an additional float variable given by user input called semi_annual_raise. Inside the loop, an addition is made after current_savings is manipulated, which checks if the current month is a multiple of 6 using months % 6 == 0. If it is a multiple of 6, the annual salary multiplies by 1 plus the semi-annual raise rate.
![ps1b](https://user-images.githubusercontent.com/107879635/175647386-482ae50f-b85d-4a9f-bc9b-dbb23a993fd4.png)

C) Now, the variables semi_annual_raise, r, portion_down_payment, and total_cost are given set values, and only the original salary requires user input. The code uses a bisection search between low value 0 and high value 10000 to find the best value for portion_saved. A while True loop performs iterations of each guess for portion_saved, and break statements within the loop will terminate the code once a result is reached. The number of iterations is counted with the steps variable. Every iteration, a guess is made using the middle value between the low and high value made as an integer. The code from Part B is then used to test how the guess for portion_saved plays out. One change is that instead of going until the savings reach the down payment cost, the loop goes until 36 months have passed. Then, the difference between the savings and the down payment is calculated. If the absolute value of this difference is below 100, then it is close enough, and the current guess is printed out as the best savings rate, and the number of steps the sort took is printed as well. Otherwise, if the difference is negative and the savings ended up lower than the down payment cost, the low value is set to the current guess. If the diffrerence is positive, the high value is set to the current guess. Then, the sorting loop runs again with new low and high values, and it continues until a guess is reached that is close enough. To account for situations where the down payment will never be reached even at the highest possible rate, the code checks if the guess has reached 9999 or higher (a 100% rate) and stops the code there, printing out that it is not possible to pay the down payment. 9999 was chosen because integers were used for the low and high values, and the guess would always round down to 9999 instead of fully reaching 10000.
![ps1c](https://user-images.githubusercontent.com/107879635/175651444-8e31a7df-be93-4f4c-b7fe-966d368abbbd.png)

## Problem Set 2
1A) For the is_word_guessed function, a for loop iterates over the length of the secret word to look through each individual character. If the character is not found in the list of letters guessed, the function ends and returns False. If the loop completes without any character missing from the list of letters guessed, the function returns True.

1B) For the get_guessed_word function, an empty string variable named result is created. A for loop runs through all the characters in the secret word and sees if they are in the letters guessed. If they have been guessed, the character is added to the end of the result string. Otherwise, "_ " is added. After the loop ends, the final result variable is returned.

1C) For the get_available_letters function, all lowercase letters are put into variable allLetters using string.ascii_lowercase, and an empty string variable named letters is created. A for loop iterates through all the characters in allLetters and looks to see if they have been guessed yet. If a letter has not been guessed, it is added to the end of the letters variable. After the loop is complete, the function returns the letters variable.

2\) The hangman function takes in a string to be the secret word, and while working on it, I called the function with a placeholder word. After I was done, I used randomly selected words. The variable guesses is set to 6 and keeps track of how many guesses the player has left. The list letters_guessed is set up as an empty list. The program tells the player how many letters are in the word using len(secret_word). A while loop runs iterations for every round that passes, and ends when there are zero guesses left. At the start of a round, the program says how many guesses are left and prints out available letters using get_available_letters(letters_guessed). The program then asks for a letter to guess. Variable strikes is set to 3. If the guess is not in the alphabet, has a length that isn't 1, or is already in letters_guessed, strikes goes down by 1 and a warning is given. Once strikes hits 0, the program stops asking again and takes away a guess from the player. If a proper guess is made, the program moves onto the next step and adds the guess to letters_guessed. If the guess is not found in the secret word, it checks if the guess is either a, e, i, o, or u. If the guess is a vowel, 2 guesses are removed; otherwise, 1 is removed. The program tells the player if they guessed right and shows how much of the word has been guessed using get_guessed_word(secret_word,letters_guessed). After each round, the code tests whether the word has been fully guessed using is_word_guessed(secret_word,letters_guessed). If so, the program congratulates the player, calculates the score, and ends. The score is found by creating a list for unique letters and running through each letter in the word. If a letter is not yet in the list, it is added. The score is found by multiplying the number of guesses left by the length of the list. If the player runs out of guesses, the program ends and lets the player know what the word was.
![ps22](https://user-images.githubusercontent.com/107879635/175657865-848eefa2-cbb6-4ebd-a8f1-8f0154f9a04e.png)

3A) For the match_with_gaps function, empty string word is created, and a for loop iterates through each character in my_word. Any character that isn't a space is added to the end of word, creating a string with no spaces. The code checks whether the length of the word matches the length of other_word, and returns False if it doesn't. Then, for every character in word, if it is not an underscore, it is compared to the character at its same location in other_word. If any letter does not match, False is returned. If all letters match, True is returned. The code also checks to make sure a match is not given if an underscored letter has already appeared in the word. If it has already appeared, False is returned.

3B) For the show_possible_matches function, empty string possible_matches is created. The code iterates through every word in wordlist, and calls match_with_gaps() to see if the word matches the inputted word my_word. If it matches, the word is added to the end of possible_matches. After running through all words, if the length of the string created is 0, "No matches found" is printed. Otherwise, the string possible_matches is printed.

3C) The hangman_with_hints function is almost identical to the hangman function, but a new condition is added where the program asks for a letter. If the guess is \*, show_possible_matches(get_guessed_word(secret_word,letters_guessed)) is called to find matching words for the currently guessed letters. \* counts as a valid guess character, so the code moves on to the next round.
![ps23](https://user-images.githubusercontent.com/107879635/175660684-403749d1-2d09-4e1d-8b4c-7c899bd1cb55.png)
